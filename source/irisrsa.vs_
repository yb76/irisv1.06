////////////////////////////////////////////////////////////////////////////////////////////////////
// i-RIS security script
//
// DES key slots are used to store the RSA keys permanently
//
// Key Application Ownership is enfored by the application at a higher level.
//
////////////////////////////////////////////////////////////////////////////////////////////////////

SUBDEV		6		//	Script ID
SCRIPT		IRISRSA	//	Script Name

DEF_BLK		255 255	//	Possibly change this to "255 0" since we do not want to load keys other than by using this function.....check first...******


//**************************************************************************************************
//**************************************************************************************************
// Macro Name:	WriteDESKey
//
// Description	Loads a single length DES key into a specified key block
//
// Parameters	<= 	BYTE 0: Key Block Number
// 					BYTES 1 to 8: DES key value
//
// Return:		None
//**************************************************************************************************
MACRO			80	//	BEGIN
	LENGTH		9	//		Check for exactly 9 input bytes

	GETX		0	//		Get the key block number
	GETA		1	// 		Get the DES key value
	STAX			// 		Store the key content in the key block
EOM				0	//	END


//**************************************************************************************************
// Macro Name:	Write3DESKey
//
// Description	Write a double length 3-DES key into a specified key block
//
// Parameters	<= 	BYTE 0: Key Number
// 					BYTES 1 to 8: High Order DES key value
// 					BYTES 9 to 16: Low Order DES key value
//
// Return:		None
//**************************************************************************************************
MACRO			81	//	BEGIN
	LENGTH		17	//		Check for exactly 17 input bytes

	GETX		0	// 		Get the high order key block number
	GETA		1	// 		Get the high order DES key value
	STAX			// 		Store the high order key content in the key block

	INCX			// 		Set X to next key block number
	GETA		9	// 		Get the low order DES key value
	STAX			// 		Store the low order key content in the key block
EOM				0	//	END


//**************************************************************************************************
// Macro Name:	EraseDESKey
//
// Description	Clears a single DES key
//
// Parameters	<= 	BYTE 0: Key Block Number
//
// Return:		None
//**************************************************************************************************
MACRO			82	//	BEGIN
	LENGTH		1	// 		Check for exactly 1 input byte

	GETX		0	//		Get the key block number
	DELETEX			//		Delete the key content
EOM				0	//	END


//**************************************************************************************************
// Macro Name:	Erase3DESKey
//
// Description	Clears a 3-DES key
//
// Parameters	<= 	BYTE 0: Key Block Number
//
// Return:		None
//**************************************************************************************************
MACRO			83	//	BEGIN
	LENGTH		1	//		Check for exactly 1 input byte

	GETX		0	// 		Get the high-order key block number
	DELETEX			//		Delete high order the key content

	INCX			//		Set to the low-rder key block number position
	DELETEX			//		Delete the low order key content
EOM				0	//	END


//**************************************************************************************************
// Macro Name:	RandomDESKey
//
// Description	Create a random DES key
//
// Parameters	<= 	BYTE 0: Key Block Number
//
// Return:		None
//**************************************************************************************************
MACRO			84	//	BEGIN
	LENGTH		1	// 		Check for exactly 1 input byte

	GETX		0	//		Get the key block number
	RNDA			//		Get a random number
	STAX			//		Store the random number as the key value
EOM				0	//	END


//**************************************************************************************************
// Macro Name:	Random3DESKey
//
// Description	Create a random 3-DES key
//
// Parameters	<= 	BYTE 0: Key Block Number
//
// Return:		None
//**************************************************************************************************
MACRO			85	//	BEGIN
	LENGTH		1	//		Check for exactly 1 input byte

	GETX		0	// 		Get the high-order key block number
	RNDA			//		Get a random number
	STAX			//		Store the random number as the high order key value

	INCX			//		Set to the low-rder key block number position
	RNDA			//		Get a random number
	STAX			//		Store the random number as the low order key value
EOM				0	//	END


//**************************************************************************************************
// Macro Name:	KVCDESKey
//
// Description	Calculate the KVC of a DES key
//
// Parameters	<= 	BYTE 0: Key Block Number
//				=>	BYTE 0-7: KVC
//
// Return:		None
//**************************************************************************************************
MACRO			86	//	BEGIN
	LENGTH		1	// 		Check for exactly 1 input byte

	GETX		0	//		Get the key block number
	SELECTX			//		Make the key current

	CLRA			//		Prepare 8 bytes of all ZEROs.
	EECB			//		Encrypt it to obtain the KVC
	SENDA		0	//		Return the KVC
EOM				3	//	END


//**************************************************************************************************
// Macro Name:	KVC3DESKey
//
// Description	Calculate the KVC of a 3-DES key
//
// Parameters	<= 	BYTE 0: Key Block Number
//				=>	BYTE 0-7: KVC
//
// Return:		None
//**************************************************************************************************
MACRO			87	//	BEGIN
	LENGTH		1	// 		Check for exactly 1 input byte

	GETX		0	//		Get the key block number
	ALGO_DES112		//		Set the key length (double)
	SELECTX			//		Make the key current

	CLRA			//		Prepare 8 bytes of all ZEROs.
	EECB			//		Encrypt it to obtain the KVC
	SENDA		0	//		Return the KVC
EOM				3	//	END




//**************************************************************************************************
//**************************************************************************************************
// Macro Name:	CopyDESKey
//
// Description	Copies a single DES KEK key from one key block to another
//
// Parameters	<= 	BYTE 0: Index of source KEK key block
// 					BYTE 1: Index of destination KEK key block
//
// Return:		None
//**************************************************************************************************
MACRO			90	//	BEGIN
	LENGTH		2	//		Check for exactly 2 input bytes

	GETX		0	//		Get the source key block number
	LDAX			//		Load the source key content
	
	GETX		1	//		Load the destination key block number
	STAX			//		Store the source key content into the destination key block
EOM				0	//	END


//**************************************************************************************************
// Macro Name:	Copy3DESKey
//
// Description	Copies a 3-DES key from one key block to another
//
// Parameters	<= 	BYTE 0: Index of source 3-DES key block
// 					BYTE 1: Index of destination 3-DES key block
//
// Return:		None
//**************************************************************************************************
MACRO			91	//	BEGIN
	LENGTH		2	//		Check for exactly 2 input bytes

	GETX		0	//		Get the source high order key block number
	LDAX			//		Load the high order high order key content
	
	GETX		1	//		Get the destination high order key block number
	STAX			//		Store the source high order key content into the destination key block

	// Ditto for the low order DES key
	GETX		0
	INCX
	LDAX
	GETX		1
	INCX
	STAX
EOM				0	//	END


//**************************************************************************************************
// Macro Name:	MoveDESKey
//
// Description:	Moves a single DES key from one key block to another
//
// Parameters:	<= 	BYTE 0: Index of source key block
// 					BYTE 1: Index of destination key block
//
// Return:		None
//**************************************************************************************************
MACRO			92	//	BEGIN
	LENGTH		2	//		Check for exactly 2 input bytes

	GETX		0	//		Get the source key block number
	LDAX			//		Load the key content
	DELETEX			//		Erase the key from the source key block
	
	GETX		1	//		Load the destination key block number
	STAX			//		Store the source key content into the destination key block
EOM				0	//	END


//**************************************************************************************************
// Macro Name:	Move3DESKey
//
// Description	Moves a 3-DES key from one key block to another
//
// Parameters	<= 	BYTE 0: Index of source 3-DES key block
// 					BYTE 1: Index of destination 3-DES key block
//
// Return:		None
//**************************************************************************************************
MACRO			93	//	BEGIN
	LENGTH		2	//		Check for exactly 2 input bytes

	GETX		0	//		Get the source key block number
	LDAX			//		Load the high order key content
	DELETEX			//		Erase the key from the source key block
	
	GETX		1	//		Get the destination key block number
	STAX			//		Store the source high order key content into the destination key block

	// Repeat for the low order DES key
	GETX		0
	INCX
	LDAX
	DELETEX
	GETX		1
	INCX
	STAX
EOM				0	//	END



//**************************************************************************************************
// Macro Name:	XorDESKey
//
// Description	XOR a DES key from a key block with another in a different key block and place the
//				result in a different key block. Note that the operand key values must be already
//				stored in their own blocks
//
// Parameters	<= 	BYTE 0: Index of the first single DES key block to XOR
// 					BYTE 1: Index of the second single DES key block to XOR
// 					BYTE 2: Index of single DES key block where the result is to be stored
//
// Return:		None
//**************************************************************************************************
MACRO			94	//	BEGIN
	LENGTH		3	//		Check for exactly 3 input bytes

	GETX		0	//		Get the first DES key block number
	LDAX			//		Load the first DES key
	MOV_A_B0		//		Keep the key in a temporary location B0

	GETX		1	//		Get the second DES key block number
	LDAX			//		Load the second DES key
	XORA_B0			//		XOR both key together
	ADJ_ODD			//		Adjust the result for odd parity as per DES standard

	GETX		2	//		Get the destination key block number
	STAX			//		Store the result into the destination key block
EOM				0	//	END


//**************************************************************************************************
// Macro Name:	Xor3DESKey
//
// Description	XOR a 3-DES key from a key block with another in a different key block and place the
//			result in a different key block. Note that the operand key values must be already
//			stored in their own blocks
//
// Parameters	<= 	BYTE 0: Index of the first 3-DES key block to XOR
// 					BYTE 1: Index of the second 3-DES key block to XOR
// 					BYTE 2: Index of 3-DES key block where the result is to be stored
//
// Return:		None
//**************************************************************************************************
MACRO			95	//	BEGIN
	LENGTH		3	//		Check for exactly 3 input bytes

	GETX		0	//		Get the first high order 3-DES key block number
	LDAX			//		Load the first high order 3-DES key
	MOV_A_B0		//		Keep the first high-order 3-DES key in a temporary location B0
	INCX			//		Set to the first low order 3-DES key block number
	LDAX			//		Load the first low order 3-DES key
	MOV_A_B1		//		Keep the first low-order 3-DES key in a temporary location B1

	GETX		1	//		Get the second high order 3-DES key block number
	LDAX			//		Load the second high order 3-DES key
	XORA_B0			//		XOR both high order keys together
	ADJ_ODD			//		Adjust the result for odd parity as per DES standard
	MOV_A_B0		//		Keep the result in a temporary location B0
	INCX			//		Set to the second low order 3-DES key block number
	LDAX			//		Load the second low order 3-DES key
	XORA_B0			//		XOR both low order keys together
	ADJ_ODD			//		Adjust the result for odd parity as per DES standard

	GETX		2	//		Get the destination high order key block number
	INCX			//		Set to the destination low order key block number
	STAX			//		Store the low order result into the detination low order key block
	DECX			//		Set to the destination high order key block number
	MOV_B0_A		//		Retrive the high order result
	STAX			//		Store the high order result into the destination high order key block
EOM				0	//	END






//**************************************************************************************************
//**************************************************************************************************
// Macro Name:	ClearIV
//
// Description	Clear the Initial Vector used for DES and 3-DES encryption
//
// Parameters	None
//
// Return:		None
//**************************************************************************************************
MACRO			100		//	BEGIN
	CLRIV				//		Clear the Initial Vector
EOM				0		//	END


//**************************************************************************************************
// Macro Name:	SetIV
//
// Description	Sets or clears the Initial Vector used for DES and 3-DES encryption
//
// Parameters	<=	BYTES 0 - 7: Initial Vector
//
// Return:		None
//**************************************************************************************************
MACRO			101		//	BEGIN
	LENGTH		8		//		Only set the Initial Vector if data ia available

	GETA		0		//		Get the 8-byte Initial Vector
	MOV_A_IV			//		Set the Initial Vector
EOM				0		//	END






//**************************************************************************************************
//**************************************************************************************************
// Macro Name:	DESEncrypt
//
// Description	DES Encrypt an 8 byte data block.
//
// Parameters	<= 	BYTE 0: Index of the DES key block used for encryption
// 					BYTES 1 - 8: 8 bytes data to encrypt
//				=>	BYTES 0 - 7: Encrypted data
//
// Return:		Error if key used is not a DEK, length is wrong, or key not loaded.
//				Success with encrypted data otherwise.
//**************************************************************************************************
MACRO			110		//	BEGIN
	LENGTH		9		//		Check for exactly 9 input bytes

	GETX		0		//		Get the key block number
	SELECTX				//		Select the DES key as the current DES key

	GETA		1		//		Get the 8-byte data to encrypt
	ECBC				//		Encrypt the data.

	SENDA		0		//		Output the encrypted data
EOM				8		//	END


//**************************************************************************************************
// Macro Name:	3DESEncrypt
//
// Description	3-DES Encrypt an 8 byte data block.
//
// Parameters	<= 	BYTE 0: Index of the 3-DES key block used for encryption
// 					BYTES 1 - 8: 8 bytes data to encrypt
//				=>	BYTES 0 - 7: Encrypted data
//
// Return:		Error if key used is not a DEK, length is wrong, or key not loaded.
//				Success with encrypted data otherwise.
//**************************************************************************************************
MACRO			111		//	BEGIN
	LENGTH		9		//		Check for exactly 9 input bytes

	GETX		0		//		Get the key block number
	ALGO_DES112			//		Set the key length
	SELECTX				//		Select the 3-DES key as the current key

	GETA		1		//		Get the 8-byte data to encrypt
	ECBC				//		Encrypt the data

	SENDA		0		//		Output the encrypted data
EOM				8		//	END


//**************************************************************************************************
// Macro Name:	DESEncryptWithVariant
//
// Description	DES Encrypt an 8 byte data block after varying the key with a constant variant.
//
// Parameters	<= 	BYTE 0: Index of the DES key block used for encryption
// 					BYTES 1 - 8: 8 bytes data to encrypt
// 					BYTES 9 - 16: 8 bytes key variant
//				=>	BYTES 0 - 7: Encrypted data
//
// Return:		Error if key used is not a DEK, length is wrong, or key not loaded.
//				Success with encrypted data otherwise.
//**************************************************************************************************
MACRO			112		//	BEGIN
	LENGTH		17		//		Check for exactly 17 input bytes

	GETX		0		//		Get the key block number
	LDAX				//		Load the DES key
	MOV_A_B0			//		Store it temporarily in register B0
	GETA		9		//		Get the key variant
	XORA_B0				//		Vary the key
	SELECTA				//		Make the key variant the current key

	GETA		1		//		Get the 8-byte data to encrypt
	ECBC				//		Encrypt the data

	SENDA		0		//		Output the encrypted data
EOM				8		//	END


//**************************************************************************************************
// Macro Name:	3DESEncryptWithVariant
//
// Description:	3-DES Encrypt an 8 byte data block after varying the key with a constant variant.
//
// Parameters	<= 	BYTE 0: Index of the DES key block used for encryption
// 					BYTES 1 - 8: 8 bytes data to encrypt
// 					BYTES 9 - 24: 16 bytes key variant
//				=>	BYTES 0 - 7: Encrypted data
//
// Return:		Error if key used is not a DEK, length is wrong, or key not loaded.
//				Success with encrypted data otherwise.
//**************************************************************************************************
MACRO			113		//	BEGIN
	LENGTH		25		//		Check for exactly 25 input bytes

	GETX		0		//		Get the key block number

	LDAX				//		Load the high order 3-DES key
	MOV_A_B1			//		Temporarily store it in B1.
	GETA		9		//		Get the key variant
	XORA_B1				//		Vary the key
	MOV_A_B1			//		Update the temporary storage at B1 with the varied key.

	INCX				//		Point to the low order 3-DES key block.
	LDAX				//		Load the low order 3-DES key
	MOV_A_B0			//		Store it in register B0
	GETA		17		//		Get the key variant
	XORA_B0				//		Vary the key
	MOV_A_B0			//		Update B0 with the varied low order 3-DES key
	MOV_B1_A			//		Store the varied high order 3-DES key in A.
	ALGO_DES112			//		Set the key length
	SELECTA				//		Make the key variant the current key

	GETA		1		//		Get the 8-byte data to encrypt
	ECBC				//		If operation != 1, Encrypt the data

	SENDA		0		//		Output the encrypted data
EOM				8		//	END


//**************************************************************************************************
// Macro Name:	DESDecrypt
//
// Description	DES Decrypt an 8 byte data block.
//
// Parameters	<= 	BYTE 0: Index of the DES key block used for decryption
// 					BYTES 1 - 8: 8 bytes data to decrypt
//				=>	BYTES 0 - 7: Decrypted data
//
// Return:		Error if key used is not a DDK, length is wrong, or key not loaded.
//				Success with decrypted data otherwise.
//**************************************************************************************************
MACRO			114		//	BEGIN
	LENGTH		9		//		Check for exactly 9 input bytes

	GETX		0		//		Get the key block number
	SELECTX				//		Select the DES key as the current DES key

	GETA		1		//		Get the 8-byte data to decrypt
	DCBC				//		Decrypt the data. Encrypted data will be kept as IV for next DCBC

	SENDA		0		//		Output the decrypted data
EOM				8		//	END


//**************************************************************************************************
// Macro Name:	3DESDecrypt
//
// Description	3-DES Decrypt an 8 byte data block.
//
// Parameters	<= 	BYTE 0: Index of the 3-DES key block used for decryption
// 					BYTES 1 - 8: 8 bytes data to decrypt
//				=>	BYTES 0 - 7: Decrypted data
//
// Return:		Error if key used is not a DDK, length is wrong, or key not loaded.
//				Success with decrypted data otherwise.
//**************************************************************************************************
MACRO			115		//	BEGIN
	LENGTH		9		//		Check for exactly 9 input bytes

	GETX		0		//		Get the key block number
	ALGO_DES112			//		Set the key length
	SELECTX				//		Select the 3-DES key as the current key

	GETA		1		//		Get the 8-byte data to decrypt
	DCBC				//		Decrypt the data

	SENDA		0		//		Output the decrypted data
EOM				8		//	END


//**************************************************************************************************
// Macro Name:	DESDecryptWithVariant
//
// Description	DES Decrypt an 8 byte data block after varying the key with a constant variant.
//
// Parameters	<= 	BYTE 0: Index of the DES key block used for decryption
// 					BYTES 1 - 8: 8 bytes data to decrypt
// 					BYTES 9 - 16: 8 bytes key variant
//				=>	BYTES 0 - 7: Decrypted data
//
// Return:		Error if key used is not a DDK, length is wrong, or key not loaded.
//				Success with decrypted data otherwise.
//**************************************************************************************************
MACRO			116		//	BEGIN
	LENGTH		17		//		Check for exactly 17 input bytes

	GETX		0		//		Get the key block number
	LDAX				//		Load the DES key
	MOV_A_B0			//		Store it temporarily in register B0
	GETA		9		//		Get the key variant
	XORA_B0				//		Vary the key
	SELECTA				//		Make the key variant the current key

	GETA		1		//		Get the 8-byte data to decrypt
	DCBC				//		Decrypt the data

	SENDA		0		//		Output the decrypted data
EOM				8		//	END


//**************************************************************************************************
// Macro Name:	3DESDecryptWithVariant
//
// Description:	3-DES Decrypt an 8 byte data block after varying the key with a constant variant.
//
// Parameters	<= 	BYTE 0: Index of the DES key block used for decryption
// 					BYTES 1 - 8: 8 bytes data to decrypt
// 					BYTES 9 - 24: 16 bytes key variant
//				=>	BYTES 0 - 7: Decrypted data
//
// Return:		Error if key used is not a DDK, length is wrong, or key not loaded.
//				Success with decrypted data otherwise.
//**************************************************************************************************
MACRO			117		//	BEGIN
	LENGTH		25		//		Check for exactly 25 input bytes

	GETX		0		//		Get the key block number

	LDAX				//		Load the high order 3-DES key
	MOV_A_B1			//		Temporarily store it in B1.
	GETA		9		//		Get the key variant
	XORA_B1				//		Vary the key
	MOV_A_B1			//		Update the temporary storage at B1 with the varied key.

	INCX				//		Point to the low order 3-DES key block.
	LDAX				//		Load the low order 3-DES key
	MOV_A_B0			//		Store it in register B0
	GETA		17		//		Get the key variant
	XORA_B0				//		Vary the key
	MOV_A_B0			//		Update B0 with the varied low order 3-DES key
	MOV_B1_A			//		Store the varied high order 3-DES key in A.
	ALGO_DES112			//		Set the key length
	SELECTA				//		Make the key variant the current key

	GETA		1		//		Get the 8-byte data to decrypt
	DCBC				//		Decrypt the data

	SENDA		0		//		Output the decrypted data
EOM				8		//	END


//**************************************************************************************************
// Macro Name:	DESOFBCrypt
//
// Description	DES OFB Crypt an 8 byte data block.
//
// Parameters	<= 	BYTE 0: Index of the DES key block used for encryption
// 					BYTES 1 - 8: 8 bytes of data to encrypt/decrypt (right filled with anything if not 8 bytes).
//				=>	BYTES 0 - 7: Enrypted/Decrypted data
//
// Return:		Error if key used is not a DEK, length is wrong, or key not loaded.
//				Success with encrypted data otherwise.
//**************************************************************************************************
MACRO			118		//	BEGIN
	LENGTH		9		//		Check for exactly 9 input bytes

	GETX		0		//		Get the key block number
	SELECTX				//		Select the DES key as the current key

	CLRA				//		Prepare 8 bytes of ZEROs
	ECBC				//		Encrypt them taking into account the IV.
	MOV_A_B0			//		Keep the result

	GETA		1		//		Get the data eo OFB encrypt
	XORA_B0				//		XOR with kept result to get OFB encrypted data

	SENDA		0		//		Output the encrypted data
EOM				8		//	END


//**************************************************************************************************
// Macro Name:	3DESOFBCrypt
//
// Description	3-DES OFB Crypt an 8 byte data block.
//
// Parameters	<= 	BYTE 0: Index of the 3-DES key block used for encryption
// 					BYTES 1 - 8: 8 bytes of data to encrypt/decrypt (right filled with anything if not 8 bytes).
//				=>	BYTES 0 - 7: Enrypted/Decrypted data
//
// Return:		Error if key used is not a DEK, length is wrong, or key not loaded.
//				Success with encrypted data otherwise.
//**************************************************************************************************
MACRO			119		//	BEGIN
	LENGTH		9		//		Check for exactly 9 input bytes

	GETX		0		//		Get the key block number
	ALGO_DES112			//		Set the key length
	SELECTX				//		Select the DES/3-DES key as the current key

	CLRA				//		Prepare 8 bytes of ZEROs
	ECBC				//		Encrypt them taking into account the IV.
	MOV_A_B0			//		Keep the result

	GETA		1		//		Get the data eo OFB encrypt
	XORA_B0				//		XOR with kept result to get OFB encrypted data

	SENDA		0		//		Output the encrypted data
EOM				8		//	END






//**************************************************************************************************
//**************************************************************************************************
// Macro Name:	KEKDeriveDESKey
//
// Description:	Decrypt a DES key using a DES KEK key and store the decrypted DES key
//				in the specified key block number
//
// Parameters	<= 	BYTE 0: Index of the DES Key Encryption Key
//					BYTE 1:	Index of the key block where the DES derived key should be stored
// 					BYTES 2 - 9: Encrypted DES Key
// 					BYTES 10 - 17: 8 bytes KEK variant
//
// Return:		Error if key used is not a KEK, length is wrong, or key not loaded.
//				Success.
//**************************************************************************************************
MACRO			130		//	BEGIN
	LENGTH		18		//		Check for exactly 18 input bytes

	GETX		0		//		Get the index of the KEK key block

	LDAX				//		Load the DES KEK key
	MOV_A_B0			//		Temporarily store it in B0.
	GETA		10		//		Get the KEK variant
	XORA_B0				//		Vary the KEK key
	SELECTA				//		Make the KEK key variant the current key

	GETA		2		//		Get the encrypted DES key
	DECB				//		Decrypt using the KEK. Ignore IV.
	ADJ_ODD				//		Adjust the resulting key parity.
	GETX		1		//		Get the index of the key block where the decrypted key should be stored
	STAX				//		Store the derived DES key
EOM				0		//	END


//**************************************************************************************************
// Macro Name:	3KEKDeriveDESKey
//
// Description:	Decrypt a DES key using a 3-DES KEK key and store the decrypted DES key
//				in the specified key block number
//
// Parameters	<= 	BYTE 0: Index of the 3-DES Key Encryption Key
//					BYTE 1:	Index of the key block where the DES derived key should be stored
// 					BYTES 2 - 9: Encrypted DES Key
// 					BYTES 10 - 25: 16 bytes KEK variant
//
// Return:		Error if key used is not a KEK, length is wrong, or key not loaded.
//				Success.
//**************************************************************************************************
MACRO			131		//	BEGIN
	LENGTH		26		//		Check for exactly 34 input bytes

	GETX		0		//		Get the index of the KEK key block

	LDAX				//		Load the high order 3-DES KEK key
	MOV_A_B1			//		Temporarily store it in B1.
	GETA		10		//		Get the key variant
	XORA_B1				//		Vary the key
	MOV_A_B1			//		Update the temporary storage at B1 with the varied key.

	INCX				//		Point to the low order 3-DES key block.
	LDAX				//		Load the low order 3-DES key
	MOV_A_B0			//		Store it in register B0
	GETA		18		//		Get the key variant
	XORA_B0				//		Vary the key
	MOV_A_B0			//		Update B0 with the varied low order 3-DES key
	MOV_B1_A			//		Store the varied high order 3-DES key in A.
	ALGO_DES112			//		Set the key length
	SELECTA				//		Make the key variant the current key

	GETA		2		//		Get the encrypted DES key
	DECB				//		Decrypt using the KEK. Ignore IV.
	ADJ_ODD				//		Adjust the resulting key parity.
	GETX		1		//		Get the index of the key block where the decrypted key should be stored
	STAX				//		Store the derived DES key
EOM				0		//	End


//**************************************************************************************************
// Macro Name:	3KEKDerive3DESKey
//
// Description:	Decrypt a 3-DES key using a 3-DES KEK key and store the decrypted 3-DES key
//				in the specified key block number
//
// Parameters	<= 	BYTE 0: Index of the 3-DES Key Encryption Key
//					BYTE 1:	Index of the key block where the 3-DES derived key should be stored
// 					BYTES 2 - 17: Encrypted 3-DES Key
// 					BYTES 18 - 33: 16 bytes KEK variant
//
// Return:		Error if key used is not a KEK, length is wrong, or key not loaded.
//				Success.
//**************************************************************************************************
MACRO			132		//	BEGIN
	LENGTH		34		//		Check for exactly 34 input bytes

	GETX		0		//		Get the index of the KEK key block

	LDAX				//		Load the high order 3-DES KEK key
	MOV_A_B1			//		Temporarily store it in B1.
	GETA		18		//		Get the key variant
	XORA_B1				//		Vary the key
	MOV_A_B1			//		Update the temporary storage at B1 with the varied key.

	INCX				//		Point to the low order 3-DES key block.
	LDAX				//		Load the low order 3-DES key
	MOV_A_B0			//		Store it in register B0
	GETA		26		//		Get the key variant
	XORA_B0				//		Vary the key
	MOV_A_B0			//		Update B0 with the varied low order 3-DES key
	MOV_B1_A			//		Store the varied high order 3-DES key in A.
	ALGO_DES112			//		Set the key length
	SELECTA				//		Make the key variant the current key

	GETA		10		//		Get the low order encrypted key
	DECB				//		Decrypt using the KEK. Ignore IV.
	MOV_A_B0			//		Temporarily store the decrypted unadjusted for CBC low order derived key

	GETA		2		//		Get the high order encrypted key
	XORA_B0				//		Apply CBC chaining by XORing with the previous result
	ADJ_ODD				//		Adjust the resulting key parity.
	GETX		1		//		Get the index of the key block where the decrypted key should be stored
	INCX
	STAX				//		Store the high order derived key

	GETA		2		//		Get the high order encrypted key
	DECB				//		Decrypt using the KEK. Ignore IV.
	ADJ_ODD				//		Adjust the result key parity.
	DECX				//		Point to the high order derived key block number.
	STAX				//		Store the low order derived key
EOM				0		//	End


//**************************************************************************************************
//**************************************************************************************************
// Macro Name:	KEK-OWF
//
// Description:	Perform a OWF on a single DES KEK key and store the result in the specified KEK key block number
//
// Parameters	<= 	BYTE 0: Index of the DES Key Encryption Key
//					BYTE 1:	Index of the new KEK key block
//					BYTE 2: Index of PPASN key
//
// Return:		Error if key used is not a KEK, length is wrong, or key not loaded.
//				Success.
//**************************************************************************************************
MACRO			140		//	BEGIN
	LENGTH		3		//		Check for exactly 3 input bytes

	GETX		0		//		Get the key block number
	SELECTX				//		Select the DES/3-DES key as the current key

	GETX		2		//		Get the PPASN variant location
	LDAX				//		Load the PPASN
	DECB				//		Decrypt the PPASN. Ignore IV.
	MOV_A_B0			//		Store it temporarily in B0
	LDAX				//		Load the PPASN again
	XORA_B0				//		Vary the result. This is now the new KEK key

	GETX		1		//		Get the key block number
	STAX				//		Update the single DES KEK key.
EOM				0		//	END



//**************************************************************************************************
// Macro Name:	3KEK-OWF
//
// Description:	Perform a OWF on a 3-DES KEK key and store the result in the specified KEK key block number
//
// Parameters	<= 	BYTE 0: Index of the 3-DES Key Encryption Key
//					BYTE 1:	Index of the new KEK key block
//					BYTE 2: Index of PPASN key
//
// Return:		Error if key used is not a KEK, length is wrong, or key not loaded.
//				Success.
//**************************************************************************************************
MACRO			141		//	BEGIN
	LENGTH		3		//		Check for exactly 3 input bytes

	GETX		2		//		Get the PPASN variant location
	LDAX				//		Load the PPASN
	MOV_A_B1			//		Keep it in register B1

	GETX		0		//		Get the key block number
	ALGO_DES112			//		Set the key length
	SELECTX				//		Select the DES/3-DES key as the current key

	GETX		1		//		Get the destination key block number

// ROUND 1:		Get the MAB
	CLRIV				//		No initial IV
	MOV_B1_A			//		Get the PPASN
	ECBC				//		Encrypt it.
	MOV_B1_A			//		Get the PPASN
	ECBC				//		Encrypt it to get the MAB (Message Authentication Block) as an IV.

// ROUND 2/3:	CBC encrypt [PPASN | PPASN] using the MAB as the Initial Vector
//				then XOR with [PPASN | PPASN] to get the updated KEK
	MOV_B1_A			//		Get the PPASN
	ECBC				//		Encrypt it taking into account the initial vector
	XORA_B1				//		Get the final update for the KEK
	ADJ_ODD
	STAX				//		Store the updated high order KEK key
	MOV_B1_A			//		Get the PPASN
	ECBC				//		Encrypt it
	XORA_B1				//		Get the final update for the KEK
	ADJ_ODD
	INCX
	STAX				//		Store the updated low order KEK key
EOM				0		//	END



//**************************************************************************************************
// Macro Name:	3KEK-OWFWithVariant
//
// Description:	Perform a OWF on a 3-DES KEK key and store the result in the specified KEK key block number
//
// Parameters	<= 	BYTE 0: Index of the 3-DES Key Encryption Key
//					BYTE 1:	Index of the new KEK key block
//					BYTE 2: Index of PPASN key
//
// Return:		Error if key used is not a KEK, length is wrong, or key not loaded.
//				Success.
//**************************************************************************************************
MACRO			142		//	BEGIN
	LENGTH		3		//		Check for exactly 3 input bytes

	GETX		2		//		Get the PPASN variant location
	LDAX				//		Load the PPASN
	MOV_A_B1			//		Keep it in register B1

	GETX		0		//		Get the key block number
	INCX				//		Point to the low order 3-DES key block.
	LDAX				//		Load the low order DES key
	XORA_B1				//		Vary the low order KEK key
	MOV_A_B0			//		Keep the varied low order KEK key

	DECX				//		Point to the high order 3-DES key block.
	LDAX				//		Load the high order DES key
	XORA_B1				//		Vary the high order KEK key in register A only

	ALGO_DES112			//		Set the key length
	SELECTA				//		Select the DES/3-DES key as the current key

	GETX		1		//		Get the destination key block number

// ROUND 1: Get the MAB
	CLRIV				//		No initial IV
	MOV_B1_A			//		Get the PPASN
	ECBC				//		Encrypt it.
	MOV_B1_A			//		Get the PPASN
	ECBC				//		Encrypt it to get the MAB (Message Authentication Block) as an IV.

// ROUND 2/3:	CBC encrypt [PPASN | PPASN] using the MAB as the Initial Vector
//				then XOR with [PPASN | PPASN] to get the updated KEK
	MOV_B1_A			//		Get the PPASN
	ECBC				//		Encrypt it taking into account the initial vector
	XORA_B1				//		Get the final update for the KEK
	ADJ_ODD
	STAX				//		Store the updated high order KEK key
	MOV_B1_A			//		Get the PPASN
	ECBC				//		Encrypt it
	XORA_B1				//		Get the final update for the KEK
	ADJ_ODD
	INCX
	STAX				//		Store the updated low order KEK key
EOM				0		//	END


//**************************************************************************************************
// Macro Name:	OWF
//
// Description:	Perform a OWF on a single DES DEK or DDK key and store the result in the specified DEK or DDK key block number
//
// Parameters	<= 	BYTE 0: Index of the DES Key Encryption Key
//					BYTE 1:	Index of the new KEK key block
//					BYTE 2-9: DATA to use during OWF operation
//
// Return:		Error if key used is not a KEK, length is wrong, or key not loaded.
//				Success.
//**************************************************************************************************
MACRO			143		//	BEGIN
	LENGTH		10		//		Check for exactly 10 input bytes

	GETX		0		//		Get the key block number
	SELECTX				//		Select the DES key as the current key

	GETA		2		//		Get the variant
	DECB				//		Decrypt the variant. Ignore IV.
	MOV_A_B0			//		Store it temporarily in B0
	GETA		2		//		Get the variant again
	XORA_B0				//		Vary the result. This is now the new DEK or DDK key

	GETX		1		//		Get the key block number
	STAX				//		Update the single DES KEK key.
EOM				0		//	END


//**************************************************************************************************
// Macro Name:	3OWF
//
// Description:	Perform a OWF on a single 3-DES DEK or DDK key and store the result in the specified DEK or DDK key block number
//
// Parameters	<= 	BYTE 0: Index of the 3-DES DEK or DDK
//					BYTE 1:	Index of the new 3-DES DEK or DDK
//					BYTE 2-17: DATA to use during OWF operation
//
//
// Return:		Error if key used is not a KEK, length is wrong, or key not loaded.
//				Success.
//**************************************************************************************************
MACRO			144		//	BEGIN
	LENGTH		18		//		Check for exactly 18 input bytes

	GETX		0		//		Get the key block number
	ALGO_DES112			//		Set the key length
	SELECTX				//		Select the 3-DES key as the current key

	GETX		1		//		Get the destination key block number

// ROUND 1:		Get the MAB
	CLRIV				//		No initial IV
	GETA		2		//		Get the top part of the variant
	ECBC				//		Encrypt it.
	GETA		10		//		Get the top part of the variant
	ECBC				//		Encrypt it to get the MAB (Message Authentication Block) as an IV.

// ROUND 2/3:	CBC encrypt the 128 bit variant using the MAB as the Initial Vector
//				then XOR with 128 bit variant to get the updated KEK
	GETA		2		//		Get the PPASN
	MOV_A_B1
	ECBC				//		Encrypt it taking into account the initial vector
	XORA_B1				//		Get the final update for the KEK
	ADJ_ODD
	STAX				//		Store the updated high order KEK key
	GETA		10		//		Get the PPASN
	MOV_A_B1
	ECBC				//		Encrypt it
	XORA_B1				//		Get the final update for the KEK
	ADJ_ODD
	INCX
	STAX				//		Store the updated low order KEK key
EOM				0		//	END


//**************************************************************************************************
//**************************************************************************************************
// Macro Name:	WriteRSA
//
// Description:	Store an RSA public -OR- private key in an RSA slot
//
// Parameters	<=	BYTE 0: RSA key location
//				 	BYTE 1: Key Type (EMV only).
//					BYTE 2 - 6: RID (EMV only)
//					BYTE 7: Key Index (EMV only)
//					BYTE 8: Modulus Length in bytes.
//							Example: 2 = 16 bits. Minimum ??? = 8 bytes.
//							Use 0 = 2048 bits or 256 bytes.
//							For slots 0-3: Maximum size = 252 bytes.
//					BYTE 9: Exponent Length in bytes.
//							For slots 0-3: Maximum size = 3 bytes.
//					BYTES 10-x: Modulus. x = 10  + modulus length - 1
//					BYTES (10+x)-y: Exponent. y = 10 + modulus length + exponent length - 1
//
// Return:			Error if RSA key index is > 5
//					Success.
//**************************************************************************************************
MACRO			150		//	BEGIN
	GETX		0		//		Get the RSA key index. Range (0-5)
	GETW	1	511		//		Get the RSA key
	STRSAX				//		Store the RSA public or private key
EOM				0		//	END

//**************************************************************************************************
// Macro Name:	RSACrypt
//
// Description:	Use an RSA key to encrypt(sign) / decrypt the data block
//
// Parameters	<= 	BYTE 0: RSA key location
//					BYTE 1 - modulus length: Data to encrypt (sign) / decrypt
//				=>	BYTE 0 - modulus length-1: Encrypted (signed) / decrypted data
//
// Return:			Error if RSA key index is > 5
//					Success.
//**************************************************************************************************
MACRO			151		//	BEGIN
	GETX		0		//		Get the RSA key index
	SELRSAX				//		Load the RSA key

	GETW	1	256		//		Get maximum block than can be computed = 2048 bits.
	RSACOMP				//		Encrypt (sign) / Decrypt the data block

	SENDW	0	256		//		Return the encrypted (signed) / decrypted data
EOM				256		//	END



//**************************************************************************************************
// Macro Name:	RSAInjectDESKey
//
// Description:	Use an RSA key to inject a DES key
//
// Parameters	<= 	BYTE 0: RSA key location
//					BYTE 1:	Index of DES key block
//					BYTE 2 - 257: Data to decrypt starting with the encrypted DES key.
//								Assuming block 2 PKCS format: 00 02 RR RR RR .... RR RR RR 00 [3DES KEY]
//								This leaves little choice but to assume length of RSA key. Hence, 2048 bit modulues
//
// Return:			Error if RSA key index is > 5
//					Success.
//**************************************************************************************************
MACRO			152		//	BEGIN
	LENGTH		3		//		Check for exactly 3 input bytes

	GETX		0		//		Get the RSA key index
	SELRSAX				//		Load the RSA key

	GETX		1		//		Get the 3-DES key block number

	GETW	2	256		//		Get maximum block that can be computed = 2048 bits.
	RSACOMP				//		Decrypt the data block
	SENDW	0	256		//		Place the decrypted block 2 PKCS in the communication buffer

	GETA		250		//		Get the low order 3-DES KEK key
	ADJ_ODD				//		Ensure the key has odd parity
	STAX				//		Store the low order 3DES key
EOM				0		//	END



//**************************************************************************************************
// Macro Name:	RSAInject3DESKey
//
// Description:	Use an RSA key to inject a 3-DES key
//
// Parameters	<= 	BYTE 0: RSA key location
//					BYTE 1:	Index of 3-DES key block
//					BYTE 2 - 257: Data to decrypt starting with the encrypted 3-DES key.
//								Assuming block 2 PKCS format: 00 02 RR RR RR .... RR RR RR 00 [3DES KEY]
//								This leaves little choice but to assume length of RSA key. Hence, 2048 bit modulus
//
// Return:			Error if RSA key index is > 5
//					Success.
//**************************************************************************************************
MACRO			153		//	BEGIN
	GETX		0		//		Get the RSA key index
	SELRSAX				//		Load the RSA key

	GETX		1		//		Get the 3-DES key block number

	GETW	2	256		//		Get maximum block than can be computed = 2048 bits.
	RSACOMP				//		Decrypt the data block
	SENDW	0	256		//		Place the decrypted block 2 PKCS in the communication buffer

	GETA		242		//		Get the high order 3-DES KEK key.
	ADJ_ODD				//		Ensure the key has odd parity
	STAX				//		Store the high order 3DES key

	INCX				//		Get the 3-DES key block number
	GETA		250		//		Get the low order 3-DES KEK key
	ADJ_ODD				//		Ensure the key has odd parity
	STAX				//		Store the low order 3DES key
EOM				0		//	END



//**************************************************************************************************
// Macro Name:	RSAInjectRSAKey
//
// Description:	Use an RSA key to inject an RSA key
//
// Parameters	<= 	BYTE 0: RSA key location
//					BYTE 1:	Injected RSA key location
//
//				 	BYTE 2: Key Type (EMV only).
//					BYTE 3 - 7: RID (EMV only)
//					BYTE 8: Key Index (EMV only)
//					BYTE 9: Modulus Length in bytes.
//							Example: 2 = 16 bits. Minimum ??? = 8 bytes.
//							Use 0 = 2048 bits or 256 bytes.
//							For slots 0-3: Maximum size = 252 bytes.
//					BYTE 10: Exponent Length in bytes.
//							For slots 0-3: Maximum size = 3 bytes.
//					BYTES 11-x: Modulus. x = 11  + modulus length - 1
//					BYTES (11+x)-y: Exponent. y = 11 + modulus length + exponent length - 1
//
// Return:			Error if RSA key index is > 5
//					Success.
//**************************************************************************************************
MACRO			154		//	BEGIN
	GETX		0		//		Get the RSA key index
	SELRSAX				//		Load the RSA key

	GETX		1		//		Get the injected RSA key location

	GETW	2	510		//		Get maximum block than can be computed = 2048 bits.
	RSACOMP				//		Decrypt the data block
	STRSAX				//		Store the RSA public or private key

EOM				0		//	END


//**************************************************************************************************
// Macro Name:	RSAWrap3DESKey
//
// Description:	Use an RSA key (2048-bit length) to wrap (encrypt) a 3DES key using block 2 format
//
// Parameters	<= 	BYTE 0: RSA key location
//					BYTE 1 - 3DES key location to wrap
//					BYTE 2 - modulus length-15:	Block 2 formatted data: 00 02 RR RR RR .... RR RR RR 00 [16 BYTES OF ZEROS TO BE FILLED WITH KEY HERE]
//				=>	BYTE 0 - modulue length-1: wrapped key
//
// Return:			Error if RSA key index is > 5
//					Success.
//**************************************************************************************************
MACRO			155		//	BEGIN
	GETX		0		//		Get the RSA key index
	SELRSAX				//		Load the RSA key

	GETX		1		//		Get the 3DES key location
	LDAX				//		Get the high order key
	SENDA		242		//		Store the high order 3DES key at the correct area
	INCX				//		Point to the low order key
	LDAX				//		Get the low order key
	SENDA		250		//		Store the low order 3DES key at the correct area (the end).
	GETW	2	256		//		Get maximum block that can be computed = 2048 bits.
	RSACOMP				//		Encrypt (sign) / Decrypt the data block

	SENDW	0	256		//		Return the encrypted (signed) / decrypted data
EOM				256		//	END


//**************************************************************************************************
// Macro Name:	WriteRSA
//
// Description:	Store an RSA public -OR- private key in an RSA slot. The data is encrypted with a 3DES key
//
// Parameters	<=	BYTE 0: 3DES key location
//					BYTE 1:	Start destination DES locations
//					BYTE 8: Modulus Length in bytes.
//							Example: 2 = 16 bits. Minimum ??? = 8 bytes.
//							Use 0 = 2048 bits or 256 bytes.
//							For slots 0-3: Maximum size = 252 bytes.
//					BYTE 9: Exponent Length in bytes.
//							For slots 0-3: Maximum size = 3 bytes.
//					BYTES 10-x: Modulus. x = 10  + modulus length - 1
//					BYTES (10+x)-y: Exponent. y = 10 + modulus length + exponent length - 1
//
// Return:			Error if RSA key index is > 5
//					Success.
//**************************************************************************************************
MACRO			158		//	BEGIN

	GETX		0		//		Get the key block number
	ALGO_DES112			//		Set the key length
	SELECTX				//		Select the 3-DES key as the current key

	GETX		1		//		Get the starting destination key block number

	GETA 8   ECBC INCX STAX
	GETA 16  ECBC INCX STAX
	GETA 24  ECBC INCX STAX
	GETA 32  ECBC INCX STAX
	GETA 40  ECBC INCX STAX
	GETA 48  ECBC INCX STAX
	GETA 56  ECBC INCX STAX
	GETA 64  ECBC INCX STAX

	GETA 72  ECBC INCX STAX
	GETA 80  ECBC INCX STAX
	GETA 88  ECBC INCX STAX
	GETA 96  ECBC INCX STAX
	GETA 104 ECBC INCX STAX
	GETA 112 ECBC INCX STAX
	GETA 120 ECBC INCX STAX
	GETA 128 ECBC INCX STAX

	GETA 136 ECBC INCX STAX
	GETA 144 ECBC INCX STAX
	GETA 152 ECBC INCX STAX
	GETA 160 ECBC INCX STAX
	GETA 168 ECBC INCX STAX
	GETA 176 ECBC INCX STAX
	GETA 184 ECBC INCX STAX
	GETA 192 ECBC INCX STAX

	GETA 200 ECBC INCX STAX
	GETA 208 ECBC INCX STAX
	GETA 216 ECBC INCX STAX
	GETA 224 ECBC INCX STAX
	GETA 232 ECBC INCX STAX
	GETA 240 ECBC INCX STAX
	GETA 248 ECBC INCX STAX
	GETA 256 ECBC INCX STAX

	GETA 200 ECBC INCX STAX
	GETA 208 ECBC INCX STAX
	GETA 216 ECBC INCX STAX
	GETA 224 ECBC INCX STAX
	GETA 232 ECBC INCX STAX
	GETA 240 ECBC INCX STAX
	GETA 248 ECBC INCX STAX
	GETA 256 ECBC INCX STAX

	GETA 264 ECBC INCX STAX
	GETA 272 ECBC INCX STAX
	GETA 280 ECBC INCX STAX
	GETA 288 ECBC INCX STAX
	GETA 296 ECBC INCX STAX
	GETA 304 ECBC INCX STAX
	GETA 312 ECBC INCX STAX
	GETA 320 ECBC INCX STAX

	GETA 328 ECBC INCX STAX
	GETA 336 ECBC INCX STAX
	GETA 344 ECBC INCX STAX
	GETA 352 ECBC INCX STAX
	GETA 360 ECBC INCX STAX
	GETA 368 ECBC INCX STAX
	GETA 376 ECBC INCX STAX
	GETA 384 ECBC INCX STAX

	GETA 392 ECBC INCX STAX
	GETA 400 ECBC INCX STAX
	GETA 408 ECBC INCX STAX
	GETA 416 ECBC INCX STAX
	GETA 424 ECBC INCX STAX
	GETA 432 ECBC INCX STAX
	GETA 440 ECBC INCX STAX
	GETA 448 ECBC INCX STAX

	GETA 456 ECBC INCX STAX
	GETA 464 ECBC INCX STAX
	GETA 472 ECBC INCX STAX
	GETA 480 ECBC INCX STAX
	GETA 488 ECBC INCX STAX
	GETA 496 ECBC INCX STAX
	GETA 504 ECBC INCX STAX
	GETA 512 ECBC INCX STAX

EOM				0		//	END


//**************************************************************************************************
// Macro Name:	ReWriteRSA
//
// Description:	Re-Store an RSA public -OR- private key in an RSA slot
//
// Parameters	<=	BYTE 0: 3DES key location
//				 	BYTE 1: Starting DES storage location
//				 	BYTE 2: RSA Key location
//				 	BYTE 3: Key Type (EMV only).
//					BYTE 4 - 8: RID (EMV only)
//					BYTE 9: Key Index (EMV only)
//
// Return:			Error if RSA key index is > 5
//					Success.
//**************************************************************************************************
MACRO			159		//	BEGIN

	GETX		0		//		Get the key block number
	ALGO_DES112			//		Set the key length
	SELECTX				//		Select the 3-DES key as the current key

	GETX		1		//		Get the starting destination key block number

	GETA		2		//		Shift the RSA block
	SENDA		0

	LDAX INCX ECBC SENDA 8
	GETAX INCX ECBC SENDA 16
	GETAX INCX ECBC SENDA 24
	GETAX INCX ECBC SENDA 32
	GETAX INCX ECBC SENDA 40
	GETAX INCX ECBC SENDA 48
	GETAX INCX ECBC SENDA 56
	GETAX INCX ECBC SENDA 64

	GETAX INCX ECBC SENDA 72
	GETAX INCX ECBC SENDA 80
	GETAX INCX ECBC SENDA 88
	GETAX INCX ECBC SENDA 96
	GETAX INCX ECBC SENDA 104
	GETAX INCX ECBC SENDA 112
	GETAX INCX ECBC SENDA 120
	GETAX INCX ECBC SENDA 128

	GETAX INCX ECBC SENDA 136
	GETAX INCX ECBC SENDA 144
	GETAX INCX ECBC SENDA 152
	GETAX INCX ECBC SENDA 160
	GETAX INCX ECBC SENDA 168
	GETAX INCX ECBC SENDA 176
	GETAX INCX ECBC SENDA 184
	GETAX INCX ECBC SENDA 192

	GETAX INCX ECBC SENDA 200
	GETAX INCX ECBC SENDA 208
	GETAX INCX ECBC SENDA 216
	GETAX INCX ECBC SENDA 224
	GETAX INCX ECBC SENDA 232
	GETAX INCX ECBC SENDA 240
	GETAX INCX ECBC SENDA 248
	GETAX INCX ECBC SENDA 256

	GETAX INCX ECBC SENDA 264
	GETAX INCX ECBC SENDA 272
	GETAX INCX ECBC SENDA 280
	GETAX INCX ECBC SENDA 288
	GETAX INCX ECBC SENDA 296
	GETAX INCX ECBC SENDA 304
	GETAX INCX ECBC SENDA 312
	GETAX INCX ECBC SENDA 320

	GETAX INCX ECBC SENDA 328
	GETAX INCX ECBC SENDA 336
	GETAX INCX ECBC SENDA 344
	GETAX INCX ECBC SENDA 352
	GETAX INCX ECBC SENDA 360
	GETAX INCX ECBC SENDA 368
	GETAX INCX ECBC SENDA 376
	GETAX INCX ECBC SENDA 384

	GETAX INCX ECBC SENDA 392
	GETAX INCX ECBC SENDA 400
	GETAX INCX ECBC SENDA 408
	GETAX INCX ECBC SENDA 416
	GETAX INCX ECBC SENDA 424
	GETAX INCX ECBC SENDA 432
	GETAX INCX ECBC SENDA 440
	GETAX INCX ECBC SENDA 448

	GETAX INCX ECBC SENDA 456
	GETAX INCX ECBC SENDA 464
	GETAX INCX ECBC SENDA 472
	GETAX INCX ECBC SENDA 480
	GETAX INCX ECBC SENDA 488
	GETAX INCX ECBC SENDA 496
	GETAX INCX ECBC SENDA 504
	GETAX INCX ECBC SENDA 512


	GETX		0		//		Get the RSA key index. Range (0-5)
	GETW	1	519		//		Get the RSA key
	STRSAX				//		Store the RSA public or private key



EOM				0		//	END


//**************************************************************************************************
//**************************************************************************************************
// Macro Name:	KPPPinBlock
//
// Description:	Calculate and get the pin block
//
// Parameters	<= 	BYTE 0: Index of PIN Encrypting Key
//					BYTE 1 - 8: In BCD, 4 zeros followed by the 12 right most ASCII digits of the PAN
//
// Return:			Error if key used is not a PEK, length is wrong, or key not loaded.
//					Success.
//**************************************************************************************************
MACRO			160		//	BEGIN
	LENGTH		9		//		Check for exactly 9 input bytes

	GETX		0		//		Get the 3-DES PIN key block number
	TSTXI	201 210		//		Make sure the key is a PIN type
	SELECTX				//		Select the DES key as the current key

	SETA				//		Prepare the plain text pin field
	GETPIN0				//		Store the PIN at the left of register A
	LSRA		8		//		Make room for the PIN length (top left byte)
	GETPINNB			//		Store the length of the PIN at the left of register A
	MOV_A_B0			//		Temporarily save the plain text pin field

	GETA		1		//		Get the PAN
	XORA_B0				//		Calculate clear "format-0 pin block".

	EECB				//		Encrypt the PIN block
	SENDA		0		//		Send the PIN block back
EOM				8		//	END



//**************************************************************************************************
// Macro Name:	3KPPPinBlock
//
// Description:	Calculate and get the pin block
//
// Parameters	<= 	BYTE 0: Index of PIN Encrypting Key
//					BYTE 1 - 8: In BCD, 4 zeros followed by the 12 right most ASCII digits of the PAN
//
// Return:			Error if key used is not a PEK, length is wrong, or key not loaded.
//					Success.
//**************************************************************************************************
MACRO			161		//	BEGIN
	LENGTH		9		//		Check for exactly 9 input bytes

	GETX		0		//		Get the 3-DES PIN key block number
	TSTXI	201 209		//		Make sure the key is a PIN type
	ALGO_DES112			//		Set the key length (3-DES).
	SELECTX				//		Select the 3-DES key as the current key

	SETA				//		Prepare the plain text pin field
	GETPIN0				//		Store the PIN at the left of register A
	LSRA		8		//		Make room for the PIN length (top left byte)
	GETPINNB			//		Store the length of the PIN at the left of register A
	MOV_A_B0			//		Temporarily save the plain text pin field

	GETA		1		//		Get the PAN
	XORA_B0				//		Calculate clear "format-0 pin block".

	EECB				//		Encrypt the PIN block
	SENDA		0		//		Send the PIN block back
EOM				8		//	END



//**************************************************************************************************
// Macro Name:	KPPPinBlockWithVariant
//
// Description:	Calculate and get the pin block
//
// Parameters	<= 	BYTE 0: Index of PIN Encrypting Key
//					BYTE 1 - 8: In BCD, 4 zeros followed by the 12 right most ASCII digits of the PAN
//					BYTE 9 - 16: 6 BCD digits representing the STAN followed by 10 BCD '0's
//					BYTE 17 - 24: Transaction Amount in 16 BCD digits
//
// Return:			Error if key used is not a PEK, length is wrong, or key not loaded.
//					Success.
//**************************************************************************************************
MACRO			162		//	BEGIN
	LENGTH		25		//		Check for exactly 25 input bytes

	GETX		0		//		Get the 3-DES PIN key block number
	TSTXI	201 210		//		Make sure the key is a PIN type
	SELECTX				//		Select the DES key as the current key

	GETA		9		//		Get the STAN block
	MOV_A_B0			//		Keep it.
	GETA		17		//		Get the transaction amount block
	XORA_B0				//		This is the PIN OWF value
	MOV_A_B0			//		Keep it.

	DECB				//		Vary the data
	XORA_B0				//		This is the OWF of the PIN key.
	SELECTA				//		Select the updated PIN key (KPE) as this transaction pin key.

	SETA				//		Prepare the plain text pin field
	GETPIN0				//		Store the PIN at the left of register A
	LSRA		8		//		Make room for the PIN length (top left byte)
	GETPINNB			//		Store the length of the PIN at the left of register A
	MOV_A_B0			//		Temporarily save the plain text pin field

	GETA		1		//		Get the PAN
	XORA_B0				//		Calculate clear "format-0 pin block".

	EECB				//		Encrypt the PIN block
	SENDA		0		//		Send the PIN block back
EOM				8		//	END



//**************************************************************************************************
// Macro Name:	3KPPPinBlockWithVariant
//
// Description:	Calculate and get the pin block
//
// Parameters	<= 	BYTE 0: Index of PIN Encrypting Key
//					BYTE 1 - 8: In BCD, 4 zeros followed by the 12 right most ASCII digits of the PAN
//					BYTE 9 - 16: 6 BCD digits representing the STAN followed by 10 BCD '0's
//					BYTE 17 - 24: Transaction Amount in 16 BCD digits
//
// Return:			Error if key used is not a PEK, length is wrong, or key not loaded.
//					Success.
//**************************************************************************************************
MACRO			163		//	BEGIN
	LENGTH		25		//		Check for exactly 25 input bytes

	GETX		0		//		Get the 3-DES PIN key block number
	TSTXI	201 209		//		Make sure the key is a PIN type
	ALGO_DES112			//		Set the key length (3-DES).
	SELECTX				//		Select the 3-DES key as the current key

// PIN-OWF ROUND1: Get the MAB
	CLRIV				//		No initial IV.
	GETA		9		//		Get the STAN block
	ECBC				//		Encrypt it.
	GETA		17		//		Get the transaction amount block
	ECBC				//		Encrypt it to get the MAB (Message Authentication Block) in IV.

// PIN-OWF ROUND 2: CBC encrypt the [STAN | AMOUNT] using the MAB as the Initial Vector
	GETA		9		//		Get the STAN block
	ECBC				//		Encrypt it taking into account the initial vector
	MOV_A_B1			//		also keep the result for later
	GETA		17		//		Get the transaction amount block
	ECBC				//		Encrypt it
	MOV_A_B0			//		and keep the result

// PIN-OWF ROUND 3: XOR the encrypted [STAN | AMOUNT] with the [STAN | AMOUNT] to get the final result
	GETA		17		//		Get the transaction amount block
	XORA_B0				//
	MOV_A_B0			//		
	GETA		9		//		Get the STAN block
	XORA_B1				//
	SELECTA				//		Select the updated PIN key (KPE) as this transaction pin key.

	SETA				//		Prepare the plain text pin field
	GETPIN0				//		Store the PIN at the left of register A
	LSRA		8		//		Make room for the PIN length (top left byte)
	GETPINNB			//		Store the length of the PIN at the left of register A
	MOV_A_B0			//		Temporarily save the plain text pin field

	GETA		1		//		Get the PAN
	XORA_B0				//		Calculate clear "format-0 pin block".

	EECB				//		Encrypt the PIN block
	SENDA		0		//		Send the PIN block back
EOM				8		//	END
